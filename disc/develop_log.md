# 开发日志

## 2021-07-29

针对我自己提的需求, 做个测试丢失数据最少的方案是啥?

我使用 5G 一个数据包, 对 200G 数据进行分割共 40 个数据包, 每 5 个数据包存储在一张光盘上, 共使用 8 张盘, 双份存储 16 张盘. 问题就转换成, 16 张盘丢失 6 张后我丢失多少数据, 什么组合方式我丢失数据最少.

分组A组: `[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25],[26,27,28,29,30],[31,32,33,34,35],[36,37,38,39,40]]`

只需要考虑B组的方案. 不用对`40!`中的排练方案进行任意取二进行测试, 因为选择两组, 第一组对序号重新名称成"A组"的, 第二组做响应的调整, 就又变回只考虑 B 的组合了.

测试四中情况, 组合中不考虑单张光盘存储存储一个数据包两次的情况

1. 两个A分组, A分组生成公式`[[y*5+1..y*5+5] | y <- [0..7]]`
2. 生成公式`[[y+x*8|x <-[0..4]]| y<-[1..8]]`, `[[1,9,17,25,33],[2,10,18,26,34],[3,11,19,27,35],[4,12,20,28,36],[5,13,21,29,37],[6,14,22,30,38],[7,15,23,31,39],[8,16,24,32,40]]`
3. 分组A转换得到, `[[1,6,11,16,21],[26,31,36,2,7],[12,17,22,27,32],[37,3,8,13,18],[23,28,33,38,4],[9,14,19,24,29],[34,39,5,10,15],[20,25,30,35,40]]`
4. 使用 `2` 和 `3` 的分组进行组合

16个分组, 丢失 30% 向上取整实际丢失 6 张个分组, 保留 10 个分组. 总共有 8008 中情况.

测试结果

| 序号 | 保留数据可能情况 | 分布情况\(25~40\) | 保留数据期望 |
| --- | --- | --- | --- | 
| 1 | `[25,30,35,40]` | `[56,0,0,0,0,1680,0,0,0,0,4480,0,0,0,0,1792]` | 35 |
| 2 | `[31,32,33,34,35,36,37,38,40]` | `[0,0,0,0,0,0,8,112,648,2072,2744,1464,720,184,0,56]` | 35 |
| 3 | `[31,32,33,34,35,36,37,38,40]` | `[0,0,0,0,0,0,8,112,648,2072,2744,1464,720,184,0,56]` | 35 |
| 4 | `[28,30,31,32,33,34,35,36,37,38,39,40]` | `[0,0,0,2,0,14,100,242,692,2052,2112,1560,808,296,68,62]` | 35 |

测试完发现四中方式的数学期望都一样, 猜测可能所有组合的保留期望都是 35 . 这个咋证明呢? 

测试用代码
```hs
-- 生成所有组合方案
ff (x:xs) = ff xs ++ map (x:) (ff xs)
-- 计算保留数量
sort . map (\n -> length $  nub . sort . concat $n ) . filter (\n-> length n ==10) .ff $two
-- 计算分布情况
stat xs = let letters = [25..40] in [length [y|y<-xs, y==x] | x<-letters]
-- 计算期望
sum $  zipWith (*) (map (/8008)  [0,0,0,2,0,14,100,242,692,2052,2112,1560,808,296,68,62]) [25..40]
```

