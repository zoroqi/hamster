# 开发日志

## 2021-07-29

针对我自己提的需求, 做个测试丢失数据最少的方案是啥?

我使用 5G 一个数据包, 对 200G 数据进行分割共 40 个数据包, 每 5 个数据包存储在一张光盘上, 共使用 8 张盘, 双份存储 16 张盘. 问题就转换成, 16 张盘丢失 6 张后我丢失多少数据, 什么组合方式我丢失数据最少.

分组A组: `[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25],[26,27,28,29,30],[31,32,33,34,35],[36,37,38,39,40]]`

只需要考虑B组的方案. 不用对`40!`中的排练方案进行任意取二进行测试, 因为选择两组, 第一组对序号重新名称成"A组"的, 第二组做响应的调整, 就又变回只考虑 B 的组合了.

测试四中情况, 组合中不考虑单张光盘存储存储一个数据包两次的情况

1. 两个A分组, A分组生成公式`[[y*5+1..y*5+5] | y <- [0..7]]`
2. 生成公式`[[y+x*8|x <-[0..4]]| y<-[1..8]]`, `[[1,9,17,25,33],[2,10,18,26,34],[3,11,19,27,35],[4,12,20,28,36],[5,13,21,29,37],[6,14,22,30,38],[7,15,23,31,39],[8,16,24,32,40]]`
3. 分组A转换得到, `[[1,6,11,16,21],[26,31,36,2,7],[12,17,22,27,32],[37,3,8,13,18],[23,28,33,38,4],[9,14,19,24,29],[34,39,5,10,15],[20,25,30,35,40]]`
4. 使用 `2` 和 `3` 的分组进行组合

16个分组, 丢失 30% 向上取整实际丢失 6 张个分组, 保留 10 个分组. 总共有 8008 中情况.

测试结果

| 序号 | 保留数据可能情况 | 分布情况\(25\~40\) | 保留数据期望 |
| --- | --- | --- | --- |
| 1 | `[25,30,35,40]` | `[56,0,0,0,0,1680,0,0,0,0,4480,0,0,0,0,1792]` | 35 |
| 2 | `[31,32,33,34,35,36,37,38,40]` | `[0,0,0,0,0,0,8,112,648,2072,2744,1464,720,184,0,56]` | 35 |
| 3 | `[31,32,33,34,35,36,37,38,40]` | `[0,0,0,0,0,0,8,112,648,2072,2744,1464,720,184,0,56]` | 35 |
| 4 | `[28,30,31,32,33,34,35,36,37,38,39,40]` | `[0,0,0,2,0,14,100,242,692,2052,2112,1560,808,296,68,62]` | 35 |

测试完发现四中方式的数学期望都一样, 猜测可能所有组合的保留期望都是 35 . 这个咋证明呢? 

测试用代码
```hs
import Data.List

-- 生成所有组合方案
ff :: [a] -> [[a]]
ff [] = [[]]
ff (x:xs) = ff xs ++ map (x:) (ff xs)

-- 计算保留数量
sort . map (\n -> length $  nub . sort . concat $n ) . filter (\n-> length n ==10) .ff $two
-- 计算分布情况
stat xs = let letters = [25..40] in [length [y|y<-xs, y==x] | x<-letters]
-- 计算期望
sum $  zipWith (*) (map (/8008)  [0,0,0,2,0,14,100,242,692,2052,2112,1560,808,296,68,62]) [25..40]
```

## 2021-08-02

关于数学期望的计算, 我认为是等价与`[1-40,1-40]`这个集合随机删除30个之后剩余数量的期望. 期望计算公式
$$
\frac{P^{40}_{15}}{80!}*25+\frac{P^{40}_{14}*25*24}{80!}*26+\frac{P^{40}_{13}*26*25*24}{80!}*27+\dots+\frac{P^{40}_{0}*P^{40}_{30}}{80!}*40\\
= \sum_{i=0}^{15} \frac{P^{40}_{i}*P^{40-i-1}_{(15-i)*2}}{80!}*(40-i)
$$

思考错误, 排列组合有问题. 重新写公式. `[1-40]`, 保留`25~40`的期望
$$
C_{6}^{49}=\frac{49!}{6!43!}\\

所有可能=\sum_{i=0}^{15} {C^{40}_{i}*C^{40-i}_{(15-i)*2}}\\

期望=\sum_{i=0}^{15} \frac{C^{40}_{i}*C^{40-i}_{(15-i)*2}}{所有可能}*(40-i)\\

=\frac{\sum_{i=0}^{15} C^{40}_{i}*C^{40-i}_{(15-i)*2}*(40-i)}{\sum_{i=0}^{15} {C^{40}_{i}*C^{40-i}_{(15-i)*2}}} (1.1)\\ 

=\frac{\sum_{i=0}^{15} \frac{1}{i!(40-i)!}*C^{40-i}_{(15-i)*2}*(40-i)}{\sum_{i=0}^{15} {\frac{1}{i!(40-i)!}*C^{40-i}_{(15-i)*2}}} (1.2)\\

= \frac{\sum_{i=0}^{15} \frac{1}{i!*(30-i*2)!*(10+i)!}*(40-i)}{\sum_{i=0}^{15} \frac{1}{i!*(30-i*2)!*(10+i)!}} (1.3)\\
$$

通过 haskell 计算, 最后结果是`31.43`. 不是"35"的原因. 一可能我的猜测是错误的, 二和我期望的形式并不等价, 三数学公式写错了, 四代码写错了, 五计算精度最后产生的误差\(但是误差有点大, 有3.6的误差\)

```hs
(!) n = foldl (*) 1 [1..n]
c u d = (!)u/( (!) d * (!)(u-d))
miss i = (c 40 i) * (c (40-i) ((15-i)*2))
all = sum . map miss $ [0..15]
expe = sum . map (\n->(40-n)*(miss n)/all) $ [0..15]
```

先测试精度问题, 优化一下公式, 后的结果发生变化. 使用\(1.1\)公式得到的期望是 `31.43`, 而是用\(1.2\)则是`32.49`, \(1.3\)期望是`31.43`. 代码感觉问题不大, 所以就是我数学公式或我的猜测有问题, 而这里关于数学部分我就放弃了.  

测试了一个随记组合, 最后期望也是"35", 关于切片存储方案结论是完全镜像可能是个更好的选择, 实现简单, 整体期望不是差很多.

算了下机械硬盘的价钱, 发现硬盘更便宜. 如果使用`m disc`规格光盘, 淘宝在 `1G/元` 比磁盘贵多了, 使用其他类型光盘适合机械硬盘一个价钱的. 但我的需求并没有太大变化, 不是很想用 NAS 方案, 这个方案对我没啥吸引力, 我需要一直插着电, 我更倾向于数据不用了就放在某个盒子, 要看东西的时候找到就好了, 本身存储的就是动画, 漫画, 音乐这种文件, 不需要立刻打开地址下载下来, 而且可以选择移动我的数据, 不一定要依托于某个平台, 只要有光驱\(蓝光\), 电脑和索引文件就可以看了, 要是采用硬盘存储, 那只要有电脑和索引文件就可以看了.  我不使用 SQLite 做最终存储的原因之一就是我需要一个安装程序. 

## 2021-08-11

1. 存储结构使用`json`或`yaml`进行存储, 将数据写入`SQLite`提供检索和查询使用, 可以快速构建查询结构. 
2. 进行扫描文件的时候需要生成一个文件对应摘要
    * 暂时考虑是用 md5sum 进行完整摘要
    * windows使用`certutil -hashfile filepath MD5` 可以进行相同的摘要
3. 我文件和可能在树莓派上跑, 1.2G 文件用 MacMini 需要 2s 时间, 树莓派\+机械硬盘的组合可能更久, 要是数据太多, 摘要成本太高了.
    * 没有摘要使用 MD5 对全文件进行摘要
    * 快速摘要, 只摘要前 1M 的数据可能就够用了.

